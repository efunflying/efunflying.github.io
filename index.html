<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>迎风飞翔</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="迎风飞翔">
<meta property="og:url" content="https://efunflying.github.io/index.html">
<meta property="og:site_name" content="迎风飞翔">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="迎风飞翔">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">迎风飞翔</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
          <a class="main-nav-link" href="/atom.xml">订阅</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://efunflying.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-repair-tcp-connection" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/19/repair-tcp-connection/" class="article-date">
  <time datetime="2017-07-19T14:07:04.000Z" itemprop="datePublished">2017-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/repair-tcp-connection/">(译)修复TCP连接</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是2012年的一篇老文章了，最近在做产品kernel base upgrading的事，从2.6.32到3.10的迁移过程中，原来在kernel中实现man in middle支持的patch在porting到3.10后出了一点问题，为maninmid建立的新socket工作不正常，看起来和新的kernel改动有关。在排查问题的时候偶然发现了这篇文章，觉得有了TCP_REPAIR这种模式的支持，原来的代码看起来可以实现得更加优雅，虽然不确定最终是否会采用这种方案，因为它会需要修改用户态daemon的实现，不知道领导是否有意见，但从技术上，觉得这是个好方向。</p>
<p>================================译文分割线============================================</p>
<p>把一个正在运行的container从一台物理主机迁移到另一台物理主机是件在许多层面上都很tricky的事。尤其当container拥有许多与外部的active网络连接的时候，问题就变得更加困难。一个自然的想法是希望这些连接能够随着container迁移到新的物理主机上，而且最好远端都对此过程毫无察觉，不过Linux网络栈在编写是并没有考虑这样的移动的。即使这样，似乎随着Pavel Emelyanov的TCP connection repair patches，网络连接的transparent relocation，将在3.5版本的内核上得到支持。</p>
<p>迁移TCP连接的第一步是收集该连接当前所有可能的信息。这些信息目前在用户态很多都能获取到。通过挖掘/proc和/sys，可以确定对端的地址和端口，发送和接收队列的大小，TCP的sequence number，以及两端协商而得到的一堆参数。当然仍然有一些参数是用户态获取不到的，所以为了完成这个任务，内核也需要提供一些额外的支持。</p>
<p>对于拥有适当特权（CAP_NET_ADMIN）的进程，Pavel的patch提供了这样的支持。为了深入一个active的网络连接的内部，用户空间需要使用新引入的TCP_REPAIR选项，通过setsocketopt()系统调用，将相关的socket置于“修复模式(repair mode)”下，并且此时的socket必须处于关闭或者“established”状态下。一旦socket被置于修复模式，它就能以数种方式进行操控。</p>
<p>其中一种方式是读取发送和接受队列的内容。发送队列包含了还没有成功发送到对端的数据，这些数据需要随着连接一起迁移，这样它们就能在新的机器上被继续发送。接受队列包含了已从对端接收到，但是还没有来得及被即将迁移的应用程序处理的数据，它们也应该迁移过去，以供到了新的机器上被迁移过去的应用程序读取。获取这两个队列的内容是通过两个步骤完成的：（1）调用setsockopt(TCP_REPAIR_QUEUE)，带上参数TCP_RECV_QUEUE或者TCP_SEND_QUEUE，然后（2）调用recvmesg()来读取(1)中选取队列的内容。</p>
<p>事实上在用户空间只有一种重要的信息获取不到：两端在连接建立时协商后确定的MSS的最大值。为了取到这个值，Pavel的patch改变了处于维修模式下时，socket选项TCP_MAXSEG的语义，它将返回最大的”clamp” MSS值，而不再是当前正在使用的值。</p>
<p>最后，如果一个连接在它处于维修模式的时候结束了，那么它将被简单的删除掉，而不会给对端任何的通知。也就是说FIN包和RST包都不会发，因此对端将对情况的变化一无所知。</p>
<p>然后就是到新主机上建立连接的事了，这是通过在新主机上新建一个socket并且将其立即置入修复模式实现的。这个socket之后可以被绑定到合适的端口上，处于修复模式的时候，对于端口号进行的寻常检查将被暂停执行。</p>
<p>接下来又要用setsockopt设置TCP_REPAIR_QUEUE选项了，不过这次之后会调用sendmsg来restore发送和接收队列的内容。</p>
<p>另一个重要的任务是restore发送和接收的sequence number。这些sequence number通常是在连接建立时随机生成的，不过在连接迁移时不能那样做。这些sequence number通过调用setsockopt，设置TCP_QUEUE_SEQ选项来设置，队列参数的选取和使用TCP_REPAIR_QUEUE选项时一样，这样一来发送和接受队列的内容和sequence number的设定就被很好的恢复了。</p>
<p>一些协商而来的参数也需要被restore，这样两端才能彼此继续维持之前的agreement。这其中包括前面提到的MSS clamp，以及当前的MSS，window size和SACK以及TIMESTAMP是否可用的设置。最后一个新增选项TCP_REPAIR_OPTIONS，就是被添加来在用户态设置这些参数的。</p>
<p>一旦socket被恢复到了和其在旧主机上差不多的状态，就到了投入使用的时候了。当一个socket处于修复模式下时调用connect()，连接建立和协商的大部分代码会被跳过，连接会直接转到“established”状态，而不会与对端发生任何的实质通信。最后，当socket退出修复模式的时候，会发送一个window probe，以重启两端的traffic，此时socket可以在新的主机上继续正常的通信操作。</p>
<p>这些patch在几个月里已经经过了一些修订，到version 4的时候，networking的maintainer David Miller已经把它们接受到了net-next中。因此，这些改动几乎肯定将被merge进3.5版中。TCP connection repair patch并没有提供container checkpointing和restoring问题的完整solution，不过它们是这个方向上的重要一步。</p>
<p>以下是原文：</p>
<h1 id="TCP-connection-repair"><a href="#TCP-connection-repair" class="headerlink" title="TCP connection repair"></a>TCP connection repair</h1><p> Migrating a running container from one physical host to another is a tricky job on a number of levels. Things get even harder if, as is likely, the container has active network connections to processes outside of that container. It is natural to want those connections to follow the container to its new host, preferably without the remote end even noticing that something has changed, but the Linux networking stack was not written with this kind of move in mind. Even so, it appears that transparent relocation of network connections, in the form of Pavel Emelyanov’s TCP connection repair patches, will be supported in the 3.5 kernel. </p>
<p> The first step in moving a TCP connection is to gather all of the information possible about its current state. Much of that information is available from user space now; by digging around in /proc and /sys, one can determine the address and port of the remote end, the sizes of the send and receive queues, TCP sequence numbers, and a number of parameters negotiated between the two end points. There are still a few things that user space will need to obtain, though, before it can finish the job; that requires some additional support from the kernel. </p>
<p> With Pavel’s patch, that support is available to suitably privileged processes. To dig into the internals of an active network connection, user space must put the associated socket into a new “repair mode.” That is done with the setsockopt() system call, using the new TCP_REPAIR option. Changing a process’s repair mode status requires the CAP_NET_ADMIN capability; the socket must also either be closed or in the “established” state. Once the socket is in repair mode, it can be manipulated in a number of ways.</p>
<p> One of those is to read the contents of the send and receive queues. The send queue contains data that has not yet been successfully transmitted to the remote end; that data needs to move with the connection so it can be transmitted from the new location. The receive queue, instead, contains data received from the remote end that has not yet been consumed by the application being moved; that data, too, should move so it will be waiting on the new host when the application gets around to reading it. Obtaining the contents of these queues is done with a two-step sequence: (1) call setsockopt(TCP_REPAIR_QUEUE) with either TCP_RECV_QUEUE or TCP_SEND_QUEUE, then (2) call recvmesg() to read the contents of the selected queue.</p>
<p> It turns out there is only one other important piece of information that cannot already be obtained from user space: the maximum value of the MSS (maximum segment size) negotiated between the two endpoints at connection setup time. To make this value available, Pavel’s patch changes the semantics of the TCP_MAXSEG socket option (for getsockopt()) when the connection is in repair mode: it returns the maximal “clamp” MSS value rather than the currently active value.</p>
<p> Finally, if a connection is closed while it is in the repair mode, it is simply deleted with no notification to the remote end. No FIN or RST packets will be sent, so the remote side will have no idea that things have changed.</p>
<p> Then there is the matter of establishing the connection on the new host. That is done by creating a new socket and putting it immediately into the repair mode. The socket can then be bound to the proper port number; a number of the usual checks for port numbers are suspended when the socket is in repair mode. </p>
<p> The TCP_REPAIR_QUEUE setsockopt() call comes into play again, but this time sendmsg() is used to restore the contents of the send and receive queues.</p>
<p> A few negotiated parameters also need to be restored so that the two ends will remain in agreement with each other; these include the MSS clamp described above, along with the active maximum segment size, the window size, and whether the selective acknowledgment and timestamp features can be used. One last setsockopt() option, TCP_REPAIR_OPTIONS, has been added to make it possible to set these parameters from user space.</p>
<p> Another important task is to restore the send and receive sequence numbers. These numbers are normally generated randomly when the connection is established, but that cannot be done when a connection is being moved. These numbers can be set with yet another call to setsockopt(), this time with the TCP_QUEUE_SEQ option. This operation applies to whichever queue was previously selected with TCP_REPAIR_QUEUE, so the refilling of a queue’s content and the setting of its sequence number are best done at the same time.</p>
<p> Once the socket has been restored to a state approximating that which existed on the old host, it’s time to put it into operation. Whenconnect() is called on a socket in repair mode, much of the current setup and negotiation code is shorted out; instead, the connection goes directly to the “established” state without any communication from the remote end. As a final step, when the socket is taken out of the repair mode, a window probe is sent to restart traffic between the two ends; at that point, the socket can resume normal operation on the new host.</p>
<p> These patches have been through a few revisions over a number of months; with version 4, networking maintainer David Miller accepted them into net-next. From there, those changes will almost certainly hit the mainline during the 3.5 merge window. The TCP connection repair patches do not represent a complete solution to the problem of checkpointing and restoring containers, but they are an important step in that direction.</p>
<p><a href="https://lwn.net/Articles/495304/" target="_blank" rel="external">https://lwn.net/Articles/495304/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://efunflying.github.io/2017/07/19/repair-tcp-connection/" data-id="cj5b4qayv00037qr9t7p04g96" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kernel/">kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lwn-net/">lwn.net</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-algorith-reverse-matrix" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/17/algorith-reverse-matrix/" class="article-date">
  <time datetime="2017-07-17T15:45:57.000Z" itemprop="datePublished">2017-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/17/algorith-reverse-matrix/">一道矩阵转置的算法题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天和新来的同事闲聊中听到一道算法题，问一个2*5的矩阵，怎样原地转置。回来简单想了一下，画了一下图之后，思路一下就打开了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">---------</div><div class="line">| 0 | 1 |</div><div class="line">---------</div><div class="line">| 2 | 3 |                       ---------------------</div><div class="line">---------                       | 0 | 2 | 4 | 6 | 8 |</div><div class="line">| 4 | 5 |         ===&gt;          ---------------------</div><div class="line">---------                       | 1 | 3 | 5 | 7 | 9 |</div><div class="line">| 6 | 7 |                       ---------------------</div><div class="line">---------                              (2)           </div><div class="line">| 8 | 9 |</div><div class="line">---------</div><div class="line">  (1)</div></pre></td></tr></table></figure>
<p>(2)把图画成这样，就更清楚了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">                                  ---------</div><div class="line">                                  | 0 | 2 |</div><div class="line">                                  ---------</div><div class="line">---------------------             | 4 | 6 |</div><div class="line">| 0 | 2 | 4 | 6 | 8 |             ---------</div><div class="line">---------------------    ===&gt;     | 8 | 1 |</div><div class="line">| 1 | 3 | 5 | 7 | 9 |             ---------</div><div class="line">---------------------             | 3 | 5 |</div><div class="line">       (2)                        ---------</div><div class="line">                                  | 7 | 9 |</div><div class="line">                                  ---------</div><div class="line">                                     (2&apos;)</div></pre></td></tr></table></figure>
<p>看起来有这样的关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">假设原位置是k，则</div><div class="line">if (k == 2 * i)</div><div class="line">&#123;</div><div class="line">    target(k) = i;</div><div class="line">&#125; </div><div class="line">if (k == 2 * i + 1)</div><div class="line">&#123;</div><div class="line">    target(k) = 5 + i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到每个轮转最后都是一个闭环(应该是可以证明的):<br>以i=0为例，2*0+1=1, target(1)=5; target(5)=7; target(7)=8; target(8)=4; target(4)=2; target(2)=1;</p>
<p>因此有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">count = 10</div><div class="line">count = count - 2 /*首尾两单元不用动*/</div><div class="line">for(i=0; 2*i+1&lt;5 &amp;&amp; count &gt;0; i++)</div><div class="line">&#123;</div><div class="line">    transfer(2 * i + 1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">transfer(k)</div><div class="line">&#123;</div><div class="line">    for(i = k; k!=target(i); i=target(i))</div><div class="line">    &#123;</div><div class="line">        tmp = array[target(i)];</div><div class="line">        array[target(i)] = tmp;</div><div class="line">        count --; /*某个元素已经就位*/</div><div class="line">    &#125;</div><div class="line">    array[k] = tmp;</div><div class="line">    count --; /*某个元素已经就位*/</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此最终只需要移动10-2次，一个单位的临时存储就可以完成。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://efunflying.github.io/2017/07/17/algorith-reverse-matrix/" data-id="cj5b4qayt00027qr9o77xlsga" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-system-tap-kernel-update" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/09/system-tap-kernel-update/" class="article-date">
  <time datetime="2017-07-09T12:42:55.000Z" itemprop="datePublished">2017-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/09/system-tap-kernel-update/">利用SystemTap辅助查找kernel panic的原因</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在把产品kernel base从centos 6携带的2.6.32升级到centos 7携带的3.10的过程中，遇到kernel panic的case，问题可重现，且产生的vmcore现场都非常相似，判断应该是同一个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">PID: 7220   TASK: ffff88006580bec0  CPU: 1   COMMAND: &quot;dpid&quot;  </div><div class="line"> #0 [ffff8800658c7b30] machine_kexec at ffffffff81059bdb  </div><div class="line"> #1 [ffff8800658c7b90] __crash_kexec at ffffffff81105382</div><div class="line"> #2 [ffff8800658c7c60] crash_kexec at ffffffff81105470</div><div class="line"> #3 [ffff8800658c7c78] oops_end at ffffffff8168cd88</div><div class="line"> #4 [ffff8800658c7ca0] die at ffffffff8102e93b</div><div class="line"> #5 [ffff8800658c7cd0] do_trap at ffffffff8168c440</div><div class="line"> #6 [ffff8800658c7d20] do_divide_error at ffffffff8102af4e</div><div class="line"> #7 [ffff8800658c7dd0] divide_error at ffffffff81695cce</div><div class="line">    [exception RIP: tcp_select_initial_window+55]</div><div class="line">    RIP: ffffffff815c9e77  RSP: ffff8800658c7e80  RFLAGS: 00010246</div><div class="line">    RAX: 000000000000aaaa  RBX: 0000000000000000  RCX: 000000003fffc000</div><div class="line">    RDX: 0000000000000000  RSI: 0000000000000000  RDI: 000000000000aaaa</div><div class="line">    RBP: ffff8800658c7e88   R8: 0000000000000001   R9: ffff8800658c7eab</div><div class="line">    R10: ffff880138ea4e18  R12: ffff880138ea4eac  R12: ffff880135087c00</div><div class="line">    R13: 0000000000000000  R14: 00000000650cb5dc  R15: ffffffff81a97e40</div><div class="line">    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018</div><div class="line"> #8 [ffff8800658c7e90] do_tcp_setsockopt at ffffffff815be132</div><div class="line"> #9 [ffff8800658c7f18] tcp_setsockopt at ffffffff815be9b2</div><div class="line">#10 [ffff8800658c7f28] sock_common_setsockopt at ffffffff81554384</div><div class="line">#11 [ffff8800658c7f38] sys_setsockopt at ffffffff81553510</div><div class="line">#12 [ffff8800658c7f80] system_call_fastpath at ffffffff816944c9</div><div class="line">    RIP: 00007f0f4a248c0a  RSP: 00007f0ee3ffe188  RFLAGS: 00010202</div><div class="line">    RAX: 0000000000000036  RBX: ffffffff816944c9  RCX: 00007f0ee3ffe0b0</div><div class="line">    RDX: 0000000000000014  RSI: 0000000000000006  RDI: 000000000000005a</div><div class="line">    RBP: 00007f0ee3ffe180   R8: 0000000000000022   R9: 00007f0ee3ffe6ec</div><div class="line">    R10: 00007f0ee3ffe100  R11: 0000000000000246  R12: 00007f0f50490860</div><div class="line">    R13: 00007f0ee3ffe7f0  R14: 0000000000000000  R15: 000000000046a24a</div><div class="line">    ORIG_RAX: 0000000000000036  CS: 0033  SS: 002b</div></pre></td></tr></table></figure>
<p>根据调用栈，锁定这是一段这样的代码导致（这段代码来自从老kernel上porting过来的一个功能patch）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> 93 +   sync_mss = tcp_sync_mss(sk, dst_mtu(dst));</div><div class="line"> 94 +</div><div class="line"> 95 +   tp-&gt;window_clamp = dst_metric(dst, RTAX_WINDOW);</div><div class="line"> 96 +   tp-&gt;advmss = dst_metric(dst, RTAX_ADVMSS);</div><div class="line"> 97 +</div><div class="line"> 98 +   tcp_initialize_rcv_mss(sk);</div><div class="line"> 99 +   tcp_select_initial_window(tcp_full_space(sk),</div><div class="line">100 +                 tp-&gt;advmss - (tp-&gt;rx_opt.ts_recent_stamp ? tp-&gt;tcp_header_len - sizeof(struct tcphdr) : 0),</div><div class="line">101 +                 &amp;tp-&gt;rcv_wnd,</div><div class="line">102 +                 &amp;tp-&gt;window_clamp,</div><div class="line">104 +                 sysctl_tcp_window_scaling,</div><div class="line">104 +                 &amp;rcv_wscale, dst_metric(dst, RTAX_INITRWND));</div></pre></td></tr></table></figure>
<p>由64位下参数调用的习惯，可以得知100行处tcp_select_initial_window的第二个参数mss值为0, 此参数会在tcp_select_initial_window中作为除数，从而引发一个除零异常。</p>
<p>这时以前比较常用的做法是通过bt -lf打出栈内存，反汇编问题函数，然后通过推断得出各个变量的地址，然后根据类型去解相应的值，重建问题的现场。但这里的麻烦之处在于编译的优化常常会出来捣乱，让代码变得更加难读，更糟的情况是dump信息中有时并不能包含所有的内存地址，这会导致推理中断。</p>
<p>所幸的是这个问题是可以重现的，因此一个比较直观的思路是可以打log出来看一下到底那些中间变量发生了什么，如果用修改代码来实施的话，每次想收集新的信息时就得重新编译，外加更换产品的内核，很麻烦。</p>
<p>这时候SystemTap就显得非常好用，直接probe一下出问题点前的程序步，打印出相应的变量值就可以了。不过这里有个特殊的问题是这个bug的后果会导致kernel panic，因此现场信息无法及时的返回回来，所以用了个小trick，在99行调用前除了打印变量值外，把tp-&gt;advmss的值调大，这样就可以避过kernel panic，看到现场变量的值了。结果发现tp-&gt;advmess的值在函数调用时是0，tp-&gt;rx_opt.ts_recent_stamp也是0，根源在tp-&gt;advmss上。</p>
<p>通过查看kernel 3.10的代码，发现dst_metric(dst, RTAX_ADVMSS)这种方式在新的kernel中已经不再工作了，新的取值方式是dst_metric_advmss(dst); 修改为新的方式，重新build kernel，问题解决。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://efunflying.github.io/2017/07/09/system-tap-kernel-update/" data-id="cj5b4qazn000d7qr9sugi90ix" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kernel/">kernel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Machine-Learning-Start" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/25/Machine-Learning-Start/" class="article-date">
  <time datetime="2017-06-25T04:57:01.000Z" itemprop="datePublished">2017-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/25/Machine-Learning-Start/">Machine Learning课程感想</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近机器学习真是火，百年难得一见的创始人，为此竟然跑出来给大家做了次sharing，虽然内容还是很general，但是从创始人的口中了解到现在在硅谷，AI方面的购并正在大规模的发生，各大公司正在摩拳擦掌准备抢占新时代的主导权，或者至少，为应对新一轮的“洗牌”积蓄力量，以免自己成为被新浪潮抛弃掉的那一批。</p>
<p>有鉴于IT行业从来不缺乏炒概念，讲故事的热情和能力，因此对这次的AI风潮，一直也都是抱着隔岸观火的态度。毕竟根据在学校里那会儿数据挖掘课上得到的印象，机器学习还只是基于算法的一种辅助寻找大数据中有用信息和规律的手段而已，能力受限于设计者对问题的认识比较多，完全谈不上什么超越人类，取代人类。即使是Alpha Go的神奇，初看起来也只是由于剪枝做得比较好，节省了许多原本不必要的计算，外加加入了形势判断的算法，能去计算落子的效率和优劣而已。</p>
<p>不过另一方面也深知，要客观评价一个东西，得先足够了解它才行，记得上学那会儿数据挖掘课上提到神经网络的时候，只是简单的讲了一下，印象最深的还是Minsky大神在他的那本《感知机》的书中对于神经网络的数学论证，导致神经网络研究直接进入寒冬的掌故，神经网络的课也主要讲的是BP神经网络，还讲到了SVM，那个又一次把神经网络研究打入冷宫的算法，但之于当红的Deep Learning，那会儿是没有讲到的。所以正好公司内部有这样的课程就报名参加了。</p>
<p>听了几堂课下来，前面的基础知识的内容和研究生时期的课差不多，不过由于是公司的课，更偏工程方向。后面讲到深度学习的时候，才了解到目前这个方向更类似于实验科学，大家对这项技术的热衷源于它的实际效果很好，并且通过增加神经网络的深度，调试激活函数，还能取得更好的效果，并且与现有的其他模型不同，深度学习目前并没有表现出传统机器学习算法那样随着数据的增加效用逐渐趋平的天花板效应。课间和讲师同事闲聊的时候，他也坦言，现在的这个方向，理论严重滞后于实践，大家的工作更像是炼金术士，追求的是怎样可以取得更好的效果，但是对于为什么这样那样效果更好，或者是不是总是会那么好，其实大家都不清楚。</p>
<p>而这一点倒是让我感到很惊艳，因为这像极了许多科学理论大发展前的实践积累阶段，而历史也反复证明，一旦进入理论化的阶段，其发展可能是爆炸式的。而且这一次有意思的地方在于，由于神经网络最初是模拟人脑神经元的工作方式而诞生的，那么将来这方面一旦理论化，也许也意味着我们能找到对人意识思维本质这一问题的答案，并且从这个意义上讲，一旦那一天到来，机器由于其永生，外加算力强大，超越人类简直易如反掌。这也让我第一次感到人工智能也许真在某个时间点后，将完全脱离人的掌握而独立存在这种可能的现实性。</p>
<p>炼金到化学的跨越，也许也是人到神的跨越。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://efunflying.github.io/2017/06/25/Machine-Learning-Start/" data-id="cj5b4qayo00017qr9flpiyat0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-rpm-commands" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/12/rpm-commands/" class="article-date">
  <time datetime="2017-04-12T05:36:05.000Z" itemprop="datePublished">2017-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/12/rpm-commands/">一些很有用的RPM命令的总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近做一个项目，目标是把产品定制操作系统的kernel base从CentOS 6的2.6.32升级到CentOS 7的3.10，同时升级操作系统编译平台，使其可以编译出新的定制kernel包。同时希望维持产品其余部分的稳定。</p>
<p>简言之是希望把CentOS 7的kernel包加上定制patch后装到CentOS 6上，这是一个并没有官方guide的task，由于kernel的升级，不可避免的会带来toolchain的升级需求，因此在很多时候，是需要解决在过程中的包依赖（包括版本依赖）的，也就不可避免的要做一些包的backport，以使新kernel的rpm包依赖的一些rpm包能运行在CentOS 6下。</p>
<p>在这个过程中，一些命令发现被用到的频率非常高，所以在这里整理一下。</p>
<ol>
<li>rpm -qpl xxxxx.rpm     有时候下了一个包，你想知道这个包里有哪些文件，将来会被放到什么目录下，这个命令很有用</li>
<li>rpm -qf /path/to/file  有时候提示你CentOS 6下缺了某个文件，你想知道这个文件应该去CentOS 7下的哪个包里找，可以在CentOS 7下用whereis找到该文件，然后用这个命令查出属于哪个包</li>
<li>rpm2cpio xxxxx.rpm | cpio -dim  当你想查看一下rpm包内的某个文件，但却并不想安装它的时候，把它解开来是个比较简单的方法</li>
<li>rpm -qp –scripts xxxx.rpm 当你想查看一下某个rpm包在安装前后会执行哪些操作时，可以用这个命令来看，在安装过程（rpm -i）中加-vv参数可以观察这些脚本的执行情况。</li>
<li>rpm -qpR xxxxx.rpm     有时候你想提前知道某个包依赖哪些包，可以通过这个命令查看</li>
<li>rpm -q –whatrequires xxxx  查看某包被哪些包依赖</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://efunflying.github.io/2017/04/12/rpm-commands/" data-id="cj5b4qazi000c7qr9m7ypn5gp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-08-22-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/22/2015-08-22-hello-world/" class="article-date">
  <time datetime="2015-08-21T19:22:00.000Z" itemprop="datePublished">2015-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/22/2015-08-22-hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://efunflying.github.io/2015/08/22/2015-08-22-hello-world/" data-id="cj5b4qayj00007qr98ci2nmaa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kernel/">kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lwn-net/">lwn.net</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 10px;">Algorithm</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/kernel/" style="font-size: 20px;">kernel</a> <a href="/tags/lwn-net/" style="font-size: 10px;">lwn.net</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/19/repair-tcp-connection/">(译)修复TCP连接</a>
          </li>
        
          <li>
            <a href="/2017/07/17/algorith-reverse-matrix/">一道矩阵转置的算法题</a>
          </li>
        
          <li>
            <a href="/2017/07/09/system-tap-kernel-update/">利用SystemTap辅助查找kernel panic的原因</a>
          </li>
        
          <li>
            <a href="/2017/06/25/Machine-Learning-Start/">Machine Learning课程感想</a>
          </li>
        
          <li>
            <a href="/2017/04/12/rpm-commands/">一些很有用的RPM命令的总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Allen Fang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
    <a href="/atom.xml" class="mobile-nav-link">订阅</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>